---
title: Java项目优化点与通用亮点
date: 2024-03-19 03:00:00
categories: Java项目
---

## 项目待实现/可优化的点(已在计划中)

- [x] **简历别写分布式**相关的，**面试聊想法时可回答**
- [x] 使用**JWT**实现登录
- [x] 可以做接口热度的排行榜，排行榜变动时的性能压力，怎么优化解决
- [ ] 用~~时间轮~~(或其他方法，对比其他实现方法有啥好处)定时任务实现接口状态自动检测，数据库里接口信息字段用statusCode存检测结果(我在笔记里的sql建表文件中改了){改一下笔记里的sql建表文件}
- [ ] 给 ```email``` 和 ```userAccount``` 添加**唯⼀约束**(会**自动的创建唯一索引**)，加快用户创建账号时查表的速度，在MySQL中，唯一约束和唯一索引都可以实现列数据的唯一，列值可以有null(但**只能有一个**null)。创建唯一约束时，会自动的创建唯一索引。唯一约束是通过唯一索引来实现数据的唯一
- [ ] 实现订阅的接口变动(若有变动就发消息邮件)的功能(类似平台发送广告邮件的业务逻辑，用户没订阅则不发)，看看[QQ如何实现高可用的订阅推送系统](https://cloud.tencent.com/developer/article/2216345)，我不做分布式，选用 Redis 的 set 类型来存储订阅列表{双set保证所有用户在接口状态发生变化时都能收到通知(接口状态变化需要连续几次检测相同才判定(设置下线6次检测，下线或上线3小时才发邮件)，防止频繁误判，而且发邮件也需要间隔时间发送，不能一次性大量发，防止QQ、网易......的邮箱服务器封我邮箱服务器的IP，**会被判定为垃圾邮件的问题还要解决**，**自建邮箱服务器发大量邮件容易被VPS厂家封的问题还要解决**)，发送邮件时从Redis里取，省的查用户接口订阅调用表了}，并记录到MySQL的表中{用户添加或删除订阅时记录到MySQL，要注意使Redis缓存失效([实现缓存与数据库一致](https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7))}(用户查自已有没有订阅过某个接口时查MySQL不查Redis，创建 ```userID``` 和 ```interfaceId``` 的**联合索引**{**为啥用联合索引而不单独索引？**因为要实现用户查自已有没有订阅过某个接口这个功能WHERE语句需要同时限定userID和interfaceId，所以用联合索引}方便查询，要**防止索引失效**([联合索引遵循**最左匹配原则**](https://xiaolincoding.com/mysql/index/index_lose.html#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E9%9D%9E%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D))，若经常以 ```userID``` 字段查询则创建 ```(userID,interfaceId)``` 的联合索引比创建 ```(interfaceId，userID)``` 的联合索引更有效)，{问问**ChatGPT**怎么实现，及实现业务的设计难点在哪}，可以使用**消息队列**(kafka ......？)优化(消息队列中的**任务**是发送给**一个**用户的信息，没像文章中那样5000个用户打个包**一起**处理，是**一个一个用户**当作任务处理的{邮件发送有限制})
  - [x] **具体回答各种问题的整理**放下面的整理模块里(去下面看，这里不细写了)
  - [ ] 会被判定为**垃圾邮件**的问题要解决
  - [ ] 待实现[根据不同状态码调整发送策略](https://blog.csdn.net/xjmfc/article/details/105837572)
  - [ ] 自建邮箱服务器发大量邮件**容易被VPS厂家封**的问题还要解决，[解决方法](https://blog.csdn.net/weixin_39850365/article/details/111616226)
    - 发信模板：不管使用文字、图片、附件还是HTML，都**必须要使用变量**，同一内容被大量群发后，腾讯就会识别然后设置为垃圾邮件内容，所以变量是防止垃圾内容的方法之一。
    - 发信ip：通过vps切换ip来达到模拟人工操作的要求。
      - [自建邮局方法](https://nigzu.com/self-hosted-email/)并非不可行，有**避免被主流邮箱屏蔽**的方法：**使用中继主机**。我开通了[Amazon Simple Email Service (SES)](https://zhuanlan.zhihu.com/p/358780018?ref=nigzu.com)（主用）和Mailgun（备用）作为发件中继主机，SES每个月免费 62000封，Mailgun每个月免费1000封，两者免费版的都使用共享 IP 地址，理论上仍有可能因其他共享用户发送垃圾邮件或自己大量发件被收件方邮局屏蔽，送达率可能不如大厂的邮箱，解决办法是购买专用IP，但这半年来我没有碰到过邮件被拒收的情况，除了163邮箱莫名收不到Mailgun的邮件，163邮箱似乎会屏蔽大部分海外来件。
      - 此外通过中继主机发送的邮件，有些收件人客户端会显示“由 <xxxxxxxxx@xxx.xxx>代发”字样，可能会给对方带来困惑，因此最好在Amazon SES或Mailgun上配置与发件地址同一域名下的子域作为发件域。
    - Amazon Simple Email Service (SES)限制：每天50000封、每秒14封、每条消息 50 个收件人、每封邮件包括附件最大 40MB，带宽上行 40MB/秒
    - 发送时用Guava RateLimiter来限制每秒发10封邮件，这样就能避免被封IP的问题，发送出错的**重新放回消息队列**并记录重发次数超限就不发了，(千用户以内，用户多了就买企业邮箱，我不收费就用免费的方案，不行的话就不自建邮箱服务器了，还是配多个邮箱账号轮询来发邮件吧)
    - [自建邮箱服务也不可以大量发送](https://www.zhihu.com/question/283149109)
    - [SMTP/POP3协议介绍](https://zhuanlan.zhihu.com/p/84174651)。采用常用的**SMTP**作为邮件**发送协议**，采用常用的**POP3**作为邮件**读取协议**。请注意，SMTP和 POP3 (或IMAP)都是使用**TCP连接**来传送邮件的，使用TCP的目的是为了可靠地传送 邮件。
- [ ] 要实现At least once推送，看看[QQ如何实现高可用的订阅推送系统](https://cloud.tencent.com/developer/article/2216345)
  - 可以考虑引入消息队列(一般来说，消息队列的意义主要是削峰填谷、异步解耦。)对本项目而言，引入消息队列有以下好处：
    - 将**任务调度和任务执行解耦**（调度服务并不需要关心任务执行结果）；
    - 异步化，保证调度服务的高效执行，调度服务的执行是以 ms 为单位；
    - 借助消息队列实现任务的可靠消费（ At least once ）；
    - 将瞬时高并发的任务量打散执行，达到削峰的作用。
  - 实现用户级别的可靠性，即要保证所有订阅用户都被至少推送一次（At least once）。At least once推送如何实现？
    - 前提是当把用户 uin 从订阅列表中取出进行推送后，在推送结果返回之前，必须保证用户 uin 被妥善保存，以防止推送失败后没有机会再推送。由于 Redis 没有提供从一个 set 中批量 move 数据到另一个set中，这里采取的做法是通过 redis lua 脚本来保证这个操作的原子性，具体 lua 代码如下（近似）：
- [ ] ~~支付模块，具体写写支付的流程~~(支付中心：分收银台{页面展示}，订单的对内网关{支付订单和每个业务要一一对应(页面流程，接口流程)}，余额支付，购物车组合支付，第三方支付渠道，支付方法{PC支付，扫码支付，APP支付，快捷支付，余额支付，组合支付}怎么快速扩展、每个接口参数都有区别怎么做，怎么调别的支付后能够安全回调，回调丢了后或者被人伪造怎么办，退款流程)
  - 微信相关的模块分成具体的要点写，亮点就可以了。比如**微信支付**接入的**时序**和**可靠性**；可以引入如小程序**二维码的时效性**和要求
- [ ] [引入第三方单点登录SSO(GitHub、QQ、......)](https://blog.csdn.net/weixin_45626288/article/details/129727671)
- [ ] 引入第三方验证模块( 谷歌/AWS/网易/...... ) {看看校招VIP短信实现的课程}
- [ ] 学习校招VIP的实战课：短信模块，商用多平台单点登录(SSO)，支付模块...... {有的得等更新}
- [ ] 如果要做用户上传接口的功能，~~可做类似GitGuardian检查上传的代码是否有密码隐私泄露的功能(例如，专门检查配置模块)~~，检查用户提交的接口所给实例有无密码隐私泄露。
- [x] 设计了mysql主从分离(主库写，从库读)，并在**从库**进行[**全文索引**(Full-Text 索引)](https://javaguide.cn/database/mysql/mysql-index.html#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93){百万级别以下使用全文索引即可，性能不错}来实现搜索(对写库没有压力)，代替了原来直接采用多字段分别**模糊匹配**的方案{如果数据量再变大(千万级)可以考虑使用**搜索引擎**{如，ElasticSearch}代替全文索引}。怎么能够去多字段查询？搜索的字段维度？
- [ ] 实现标签，搜索，​多纬度条件查询和筛选的动态实现
- [ ] 实现**自定义标签**
- [ ] 使用[**双属性枚举**](https://www.jb51.net/article/152261.htm)的方法，枚举说明字符串就直接在代码里，数据库只存数字(能不存文本就不存，文本不好校验参数)，代码中也可以用枚举类实现的**getById()**方法**传入一个数字**来**获取**枚举值，**要判断返回值是否为空**
- [ ] 简历写**普通的**实现方案，面试时**引导面试官提问怎么优化**
- [x] 为简化查询接口对应标签的常用操作，在“接口信息表”中增加了一个varchar类型的冗余字段来存放接口对应标签的id（标签id间用逗号分隔开）；流量大了上Redis缓存
  - 使用VARCHAR字段来存储多个标签ID，然后用逗号分隔，是一种常见的简化数据库设计的做法，尤其是在一些**小型或不需要高度正规化**的数据库中。然而，这样做**会影响到数据库的拓展性、性能和数据完整性**。
  - 一个接口仅拥有少量标签时，可以在“接口信息表”中用一个varchar类型的字段存放多个标签的id（id间用逗号分隔开），使用MySQL的FIND_IN_SET函数能实现按**单个标签**查询接口，不用创建“接口标签表”，优化了按标签查询接口和查询接口标签的操作；
  - MySQL手册中[FIND_IN_SET函数](https://www.cnblogs.com/jinxiang1224/p/8468261.html)的语法解释：FIND_IN_SET(str,strlist)
    - str 要查询的字符串
    - strlist 字段名 参数以”,”分隔 如 (1,2,6,8,10,22)
    - 查询字段(strlist)中包含(str)的结果，返回结果为 null或记录
  - MySQL的**IND_IN_SET函数**确实能够查询出含有特定标签的记录，但这种方式**并不高效**，尤其是在标签数量较多或是记录数量庞大时。这是因为FIND_IN_SET是一种字符串函数，它**不会利用索引**，所以每次查询都需要进行全表扫描。
  - 如果考虑到可维护性和性能，建议使用一种更可扩展的设计，比如创建一个标签表和一个接口与标签的关联表（通常称为“联结表”或"中间表"）
  - fooId字段**可以用逗号分隔**储存成**varchar类型** 一个字段储存多个fooId，一查查个String出来再**按逗号分割**可以分出多个fooId，MySQL的**varchar类型**支持输入逗号并且MySQL有[FIND_IN_SET函数](https://www.cnblogs.com/jinxiang1224/p/8468261.html)支持逗号，fooId**数量少**的时候实现了存**可变**数量的fooId数据(**可以设置not null**)；不用设置 fooId_1、fooId_2、fooId_3...... **多个字段**(有的时候只存一个数据，但查得全查则查出的后面几个字段会是**空**，**还要判空**，且浪费空间)
- [ ] 变化较快的数据，比如点赞......缓存时间要短(一两分钟)，变化不大的数据，比如详情......缓存时间可以长点(一天)；流量上去了再用缓存，公司多项目用同一个Redis要注意key别重复了，覆盖掉别人的缓存了
- [ ] 加入操作流水表，记录各个重要操作，比如付款、改邮箱、订阅......
- [x] ```#{}``` 是预编译处理， ```${}``` 是字符串替换。传递表名、字段名用 ```${}```
- [x] 不对象转换一般就用基本数据类型，不用包装类
- [ ] 排查并解决扣费模块由于扣费父任务和反作弊子任务使用同一个线程池导致的死锁问题。
- [ ] 负责用户统计模块的开发，使用 CompletableFuture 并行加载后台用户统计模块的数据信息，平均相应时间从 3.5s 降低到 1s。
- [ ] 搭建 Mockito 服务，用于模拟第三方平台接口，方便了在网络隔离情况下的接口对接工作。
- [ ] 通过验证码和前端保持半长链接映射关系，当用户扫码关注公众号并输入验证码后，发起回调，识别用户信息并找到对应半长链接，实现系统自动登录。
- [ ] 通过 Redis 实现计数统计和用户活跃度排行，并通过先写 MySQL，再删除 Redis 的方案来保证高并发场景下的缓存一致性。
- [ ] 通过 Nginx 代理，将客户端请求转发到目标服务器的后端 API 接口，从而**解决跨域**问题。
- [ ] 反爬虫，使用自己设计的映射字体(自己画字体，做成字体包，和流传开源的不一样)对常用字体替换，直接爬虫会有乱码，但是可以抓包抓出我发的字体包，然后爬虫者一一映射上去，[爬虫教程](https://imc.ugsdk.cn/api/v2/resource/asset-sdk?msToken=MOFJrdTiWP3eLWDD6otmKN1lmR-RSmoFZxOkQgBDyW9_YLdBsLMOgcTda-hyx-m0sZ6pBUoUycYRi1kYZQhDixJkQ36mSAxQobRgiVf9SQwiBWGPkTJXBDdyrlhh9g%3D%3D&a_bogus=EvMmgOZMMsm17gS3u7kz9C%2F3qa60YW-agZEFqROEitoO)
- [ ] 编写了单元测试，本项目的单元测试覆盖率超过80%
- [ ] 频繁full gc / cpu飙升的问题排查(长稳测试可以看出有没有频繁full gc，TPS一开始稳定在15000，一段时间后性能下降到8000~9000TPS，且TPS上升下降反复来回，像锯齿，猜测是频繁full gc，开始排查)(伪造full gc：代码中埋藏内存泄漏的bug、看看博客在公司如何排查full gc，mock一些流量，排查套路{dump内存、堆的各个大小、找到那个对象导致过大一直占用内存导致full gc，定位后如何修复代码}{单凡有个项目一定会full gc})，制造内存泄漏OOM的BUG，然后制造排查、修复BUG的过程。
- [ ] 制造并发问题，比如出现死锁、HashMap导致并发问题换成ConcurrentHashMap、原子类、volatile。并发的去访问一个不支持并发的集合会出问题(但我们一般就用 了支持并发的集合)，可以伪造一个死锁现场(面试官让你写个死锁){正常好点的代码不会出现死锁，别用了}，来排查，伪造未使用并发的集合的场景，原子类
- [ ] 解决流量突增问题，限流成功了，或同步通信改异步先蓄洪再泄洪(压测/mock流量)

## 项目待实现/可优化的点以及部分具体亮点整理(酌情写到简历上，在面试中提出)

### 可能的项目亮点

1. [校招vip免费的推电影项目参考](https://www.naoffer.com/intern/weiguan/21/0/1)
    - 可以做接口热度的排行榜，排行榜变动时的性能压力，怎么优化解决
    - ​多纬度条件查询和筛选的动态实现
    - 自定义感兴趣标签，按标签推荐
1. [​校招vip免费的推推小说项目参考](https://www.naoffer.com/intern/weiguan/21/0/1)
    - 书目列表在更新频繁情况下的有效实现
    - 书籍详情在更新前后面临的性能压力
        - 描述为啥使用xx架构或中间件，例如因为作者通常在半夜12点或早上6点更新，此时间点前后十分钟左右访问量会激增，有聚集效应，所以使用xx方案应对此时间段访问量的激增
    - 较多书籍时构建查询系统
    - 定时任务自动爬取并添加书籍最新章节
    - 小程序的通知机理与平台实现
    - 搜索如何主从库分离，分离的数据同步怎么实现，搜索的质量和性能怎么样
1. ​敏感词过滤，及其性能优化
1. ​多维度大V或身份认证
1. ​订单状态
1. 这个项目的业务是可以展开的，比如说视频播放，这个功能有很多的课程或者文档在不断地去展开，怎么能够防止视频被别人探测和下载？怎么能够在视频比较大的情况下进行切片？怎么能够加上前置的广告功能？视频怎么存储？我认为这点突出去写很容易展开，而且亮点足够，跟别人写的不重复
1. 为什么并发量是500，而不是1000，你就会发现这里面跟很多框架的参数有关系，而且跟长短链接也有关系，但是你答不上来。包括为什么加redis并发量是4000，不是3000或者5000，怎么进行的估量和测试？那你这个最大并发量的情况下，有多少线程在等待状态
1. 验证码，比较常用的图形验证码或者滑块，以及它们之间的性能或者功能的对比。
1. ​用缓存，那就进一步，扩展现在有哪些缓存分类？最后决定用这种缓存，然后把缓存的对比性能分析放到简历上。一方面有着亮点和独特性，另一方面也是工作中做事情的习惯性做法，会比较吸引面试官。
1. ​这个表格有什么复杂的逻辑？poi很难实现，然后你花了大量的时间去解决它
1. ​那你就重点去把支付功能扩展开写。像描述里面说重点做了支付宝扫码或者是微信扫码的整个支付流程。能把这个讲明白，你就是比别人有优势。​它的难度在什么地方？怎么能够让它更好的流程完善？
1. 项目的上传下载文档，和评价模块可以以这个描述作为重点，怎么去具体实现的？评价怎么实现评价的图片压缩？敏感文字过滤？图片PC与移动端怎么共享共用？对一个贴的评论和对评论的评论数据库怎么设计和存储(怎么保证稳定性)？
1. 使用OOS对象存储服务，做了xxxxxxxxxx，解决多平台图片多辨率的问题，完成图片分发
1. 项目需要突出什么优势？ 做了搜索就可以把其他的模块删一下，重点讲，搜索怎么来进行？怎么能够去多字段查询？怎么能够主从分离，再到现在的弹性框架， 选择一个可以真实去做的业务点。
1. 比如说搜索如何实现主库从库的分离？分离的数据同步是怎么实现的？搜索的质量和性能怎么样？把这部分重点用两行左右的文字描述，并且掌握中其中的回答。
1. 增加一些技术亮点，比如jjwt登录，或者security权限管理等
1. 网盘项目实际上是一个产品功能难点非常多的项目，直播中会针对文件的存储、非常文件识别、下载的安全性，和下载带宽限制的商用功能点的细节进行展开
1. 外卖订餐项目实际上是一个产品功能难点非常多的项目，可以对订单、套餐等多种亮点模块进行展开
1. 项目的描述仅仅是并发，还没有写出秒杀的技术点。
1. 众筹类项目是比较常见的项目这一，重复度过高导致校招简历很难通过简历筛选。直播会对项目的核心功能模块，比如说参与资质、人数控制和回报条件等模块过手
1. 社区项目实际上是一个产品功能难点非常多的项目，包括文本和图片的合法判断、帖子多级评论、排行榜等模块，都是难点较大，面试官感兴趣的功能点
1. 复杂购物车逻辑进行产品功能难点的展开
1. 课堂学习类平台，这类产品有不少核心功能点，比如课程上传和播放，作品上传、点评流转等。但是描述里没有这些核心功能，只有非常常见的权限管理、登录等
1. 考试系统，怎么防作弊，调用摄像头
1. 针对学习系统类项目的核心功能，如课程播放、作品跟踪、专项刷题等模块进行展开，难点较多，比较容易突出项目的真实性，降低重复度
1. 新闻项目是一个很复杂的产品业务项目，不要过度追求不存在的大数据量，而是从真实的产品需求角度去展开，就会很好的降低重复度。
1. **路路通**项目是一个老牌培训班项目，但是这几年反而出现的少，重复度不高，而且项目里的产品功能点比较明显，可以很好的按照功能展开，提高简历通过率
1. 云相册的项目不需要增加这么多的中间件， 甚至出现明显的不适合的场景描述，比如异步执行图片审核，这个场景本身就不成立，如果给面试机会，这些地方就一定是给自己挖坑。
1. 比如为什么不用悲观锁，需要从场景上作为明确解答
1. 优惠券秒杀是很常见的项目模块，但是在实际商用环境里业务功能比较复杂，比如说线下券的销售和核对，券池的生成和维护，超卖的现实商业产品逻辑等
1. 咨询项目虽然比较常见，但是因为有比较具体的功能点，可以进一步提炼产品难点，使亮点更多，重复度更低。比如说计算热门文章分值本身就是一个亮点，热门的规则是怎么样的？
1. 项目的亮点不要出现明显的错误，比如论坛的敏感词过滤使用前缀树就是不合理的方案，在面试里，面试官只要一追问，就是给自己挖坑。包括对方案的选型，比如发帖和私信为什么用kafka，而不是用其它的MQ中间件，区别是什么？
1. 搜索的字段维度、付费的实现 和券相关的实现
1. 小说平台可以从产品需求细节来展开
1. 充斥着不少商业项目的错误点，比如说自定义统一的错误码，在一个大系统里的众多模块，错误提示可以上百个，统一的话，非常不方便开发。
1. 在简历的最后，提到过做过爬虫，爬过boss直聘和淘宝的信息，这个反而可以做为项目经历的亮点进行展开
1. 描述具体的话题分类或者搜索等功能
1. 上线的原创应用，就更应该讲清楚核心功能是什么，整个产品是怎么运转的。另外，不需要写项目流程或者分配流程。
1. 微信相关的模块分成具体的要点写，亮点就可以了。比如微信支付接入的时序和可靠性； 可以如小程序二维码的时效性和要求
1. 对25届985同学来说，要理清楚一个事情，明年3月就是大厂的春季&暑假实习（属于校招阶段）。但是每年都有大量的顶尖985因为没准备好，在两三个月的投递和面试后，颗粒无收。所以目标是找大厂的实习，还是先找一个中小公司的正式实习，再找暑假实习，或者直接秋招。每年都有不少985的学生，因为先后顺序出问题，所以在秋招依然没有太好的机会。
1. 分片下载，服务器端怎么分片多线程？
1. 爬虫，怎么绕过验证码，怎么周期性爬取数据，聚合整理数据，怎么统计，统计的意义，防ip被封
1. 断点续传，文件分片是前端的技术要点(前端实现，后端很难，一般是**挖坑**，但做好了是个大亮点{例如，迅雷间传，QQ间传大文件})，一般Java对大文件**正常传就好**，除非对**实时性**要求很强的项目
1. 稳定常规大流量(多开几个服务器，负载均衡后对每个服务器来说就是**正常流量**)，突发大流量(**真正要解决的**)
1. 主流还是MySQL+Redis，MongoDB存文件只有游戏文档用的场景多
1. Linux 守卫线程
1. 但是要想具体的可行的后端防重复提交的实现之前，你要考虑2个场景的区别：
    - 后端提交完全没有限制，黑客1秒反复提交10次 ；
    - 每次有限制，但是黑客设置了100个终端1s端各自重复提交同一个提问。
1. 使用**OSS**做存储和媒体服务，不用自己用定时任务实现对图片的处理(比如压缩、反转、清晰度调整)，对视频的处理(比如转码)，让OSS自动化流程，各种码率的实现了什么量级下的压缩反转，提高了效率。
1. MySQL存储数据变更，通过数据库的日志传给ElasticSearch；数据量ElasticSearch每次解析日志都要花1s以上，但前端页面不能等待那么久，且不允许查出来的是原始老数据，必须是更新后的数据；ElasticSearch用来检索搜索效率不错，但ES不是强实时性框架满足不了强实时性；可以考虑数据的预加载(看当前页的时候自动查出下一页)，那第一页咋办？(可以在MySQL的从库里查，使用全文索引{从库只存储第一页的数据，数据量就小了，**百万级别内**的数据用全文索引效果不错，**千万级别**搜索才考虑使用**搜索引擎**{如，ElasticSearch}代替全文索引})
1. **要会写SQL脚本**，商用项目不管大厂/小厂**一般不用**PageHelper 分页插件，插件性能低(且自己实现简单，故而自己定制一个)，无法自动化审核脚本
1. **亮点** 为了**反爬虫**，实现用户普通访问时能正常看到文字信息，但爬虫出来的是乱码，混用非常用编码，使用svg绘制技术
1. **防抖**一般全是**前端**处理
1. **挖坑了，不要写** **简历别写** 分布式相关的，**银行金融**要求钱不可以出错，所以还是使用**分布式事务**，一般用Oracle数据库，Oracle对分布式事务支持比MySQL好；但商业环境一般**不允许使用**分布式事务(，对性能影响大，多个业务一起锁了)，商业可以用**补偿式**方法**乐观锁**，有的时候微信支付宝会支付不成功要再付一次款，定时任务两三分钟跑一次看看有没有出错的订单或等用户主动投诉与用户沟通。
1. **挖坑了，不要写**分库分表。分库简单，分表很复杂，**与业务高度相关**且一天数据量增量要百万千万才需要分表，架构师才考
1. **挖坑了，不要写**用了MyBatisPlus，Spring分了几层
1. **挖坑了，不要写** 防止商品超卖用乐观锁/悲观锁。**乐观锁**的机制，有一万个人来update加一个随机数，同时update时有一个人的update成功了，那其他人的update都要失效，这样**每次**只能卖出**一个**，性能差，但**悲观锁**也解决不了秒杀，乐观锁和悲观锁都不用，要根据实际的量级和业务特点进行设计。
1. **挖坑了，不要写** 使用ThreadLocal实现线程隔离，因为Spring本身就是线程隔离的(默认单线程)
    - 因为99%的场景，都不会有单线程的冲突问题。**用ThreadLocal的场景**：
        - 比如说一个接口请求，他的参数格式都是固定的。但是这个接口的服务部署在两个地区的服务器上，但是产品业务上有一个特殊需求，需要确定访问是哪个地域的服务器，而且根据不同的地区有不同的处理逻辑？
        - 那就发现这个需求，跟用户访问的地址没关系，因为他在页面上发起请求的时候也不知道是哪台服务器？这就出现了线程冲突场景，也就是本身的参数是固定的没有办法需修改，包括接口本身的参数也是固定的没有办法需求改；但是相同的一个访问链接，还需要做不同的逻辑判断。
        - 那这个时候，只能在接口的参数之外，用容器赋值ThreadLocal的设置参数
1. **挖坑了，不要写**git和svn对比，
    - 很多学生可能是老师让用啥就用啥.没接触过svn对比自然无从谈起.所以面试问这个并不聪明.
其实单就学校这个场景,几名老师+每年几十名学生,单人/分组作业,如果当事人都能熟练使用,恰好能发挥git的优势;但"都能熟练使用"可能不太容易.
    - git对比svn的几个区别
        - 0.github。这个没啥可说的,如果你项目有上github的需求,至少应该让项目经理用git来做这件事;研发继续用svn无妨.同理,如果我想给公司一份自己再留一份(到外网),肯定比svn方便.
        - 1.分布式vs中心式。公司视角下这个很可能是缺点,你代码服务器天天down,公司还开不开,it部门工资还要不要.反之,实习生更容易找到机会把其他东西拷走;护网你家被社攻的时候也会更狼狈.
        - 2.分支管理+强制本地解决冲突。这俩特性是一体的.要求本地解决冲突,就必须做更好的分支管理功能,你团队越内聚,这个功能就越没用;别说"我们组5个人,有开发需求拉5个分支"这种笑话.只有当你的小组经常需要跟大项目合代码的时候,才有用.后端极少遇到这个情况,中台可能有一些,客户端超级app用得到;大型游戏团队需要,但游戏团队恐怕接受不了下一条.
        - 3.为了实现本地merge,需要付出一定代价。代价指的是开发人员精力+本地存储.很多时候我们知道自己的代码没有外部耦合、其他分支改出来的问题我也没法帮他修正,在svn里是可以把我改动的部分传上去的,git不允许,git规定谁要push就得先把merge做完.比如游戏,其他分支改了1000个资源文件索引,这跟我有啥关系?游戏配置文件(策划表)可能比较大,大到以G甚至以T计,每人本地存一套还得了?再比如做android系统的,系统源码100+G,拿服务器编译一次俩小时.整个项目40M,同事可能考下来学学;你项目10T,谁爱看谁看好吧.随着协作者人数、项目总体积增大,git的优点会变成缺点;而要不断设置分支权限、缩小每个小组、每个人的管辖范围,那为啥不用svn呢?
        - 4.svn远端同步有个好处,远端可以收集一段时间内的commit,整体分析、然后自动处理掉很多冲突.
        - 5.ai工具上马后git优势会更明显.
    - ps.有人说git可以敲命令行。在现实团队中,cvs软件能用GUI绝不要用命令行.GUI可以强制规范每个人的操作习惯,而这正是cvs的必要环节.
1. **挖坑了，不要写**Nginx配置，除非真了解各种功能如何配置
1. **挖坑了，不要写**利用MinIO分布式系统存储静态页面，代替数据库访问。大量级还有分发云服务CDN之类的加速静态页面加载的东西，存储只是一个很小的点。使用静态页面说明访问量级已经达到Redis都扛不住的情况了，动态页面最主要的消耗是查数据库出数据，优化一般把数据上Redis缓存(百万级)，还不行才用静态页面(，例如京东首页){使用一个流程模板引擎，不断把数据库里的的数据读出并生成新的静态页面，可能每分钟生成一个静态页面，每分钟更新页面上的点赞、评论之类的变动数据}
1. **挖坑了，不要写**使用字典树对输入的文本进行敏感词的检测；字典树是对英文的，一层只有26个字母，但是放到中文上一层就2000-5000，根本就不对，可以试试ElasticSearch利用Ik分词器去做分词检测，将敏感词也保存到分词器的配置文件中，这样只要文本中有敏感词，必定会被IK分词出来；且在商业上，敏感词是动态的，一定不是自己实现的，只要有一个词没考虑到，系统就可能会封
1. **挖坑了，不要写** **简历别写** 分布式相关的，优惠券使用 Redis 分布式锁，解决超卖和一人一单的问题；三个问题，为什么用分布式锁？量级很多的话，用锁会不会造成业务假死？券是券池还是当时生成？；券可以预生成的，而且每个券都是唯一的券码，为什么不直接在单个redis放可用的券码(秒杀场景是人多券少，数量100万张以下的券{一般几千几十万}单个redis就能存下**无需分布式**)，直接操作即可。
1. **挖坑了，不要写** 中间件的模拟，造轮子项目(容易**变成算法题**，算法选型为什么用这种不用另外一种)，你知道netty吗？MQ底层就是channel，是怎么实现的？【实验室**真实的**数据库引擎开发项目可以写】
1. **挖坑了，不要写** 对项目所有错误返回，统一进行接口返回信息和错误码，并封装了全局异常处理(全局异常处理是最后的屏障，异常拦不住了才用)，正常商业项目不用统一整理错误码(除非甲乙方合作类，例如微信支付公开的开放API会整理所有错误返回，统一进行接口返回信息和错误码的整理，方便对方排查出现问题的是自己程序还是微信支付提供的API)
1. **挖坑了，不要写** 使用 Redis 的位图 BitMap 实现用户的签到功能，redis内存空间不值钱，大量的数据都在放到缓存里，没必要为一个小功能所谓的单独优化，用位图虽然节省了空间，但是却**增加了计算消耗**。目前都是**用空间换时间**；场景题：签到流程是怎么样的，发现对个人签到来说是一个之前数据是**低频**的，当前数据也是**低频**的事情，用不到缓存，MySQL存就好，以前的签到数据是死的且不用经常查询；但是**上班打卡**的话，**签到时间比较集中**，可以考虑使用缓存先存缓存，再定时任务批量保存到数据库
1. 问道不会的场景题可以说没接触过，不要强答
1. 文章审核是**同步**场景，审核完了才能反馈结果给用户
1. ​算法实验室项目，展开来写针对什么问题？怎么处理？怎么生成？怎么做模型？
1. **真实性问题** 怎么跟测试进行沟通，团队有多少开发多少全职员工，项目是怎么上线的(**可以以实习的名义，简单绕过，实习生不让上线，只能测试环境**，测试环境流程也要明白。但是只是一个判别问题，一两句话描述一下就行{通过git或svn提交对应的版本分支，通过自动化工具jenkins来发布分支，通过日志工具远程到日志环境看运行情况有没有bug，有bug就回滚再次发布})；
1. **前端知识点**Websocket协议、sse协议
1. **前端**Honor商城项目的首页是有大亮点的，比如自适应和轮播兼容等；搜索模块更是要考虑点击的频度，可以很好的展开和强调难点。
1. **前端**组件封装，文件上传模块(上传给腾讯云阿里云，跨域、安全、认证、时效性、文档参数不一样)，商用回复(二级评论{对评论的评论}，一级能有头像二级不可以，能不能富文本，能不能表情包，能不能点赞，不同级别可选，发布列表排序，能不能展示，关键字过滤，回复去重，防抖，发图的大小尺寸比例折叠压缩满足移动端要求)。

## 项目整理和小亮点(小亮点别写到简历上)

> [对于此项目，别人的面经(点击跳转查看)，大致看看不一定对](API开放平台项目面经.md)

### Java里面你了解的一些锁，按照锁的粒度排个序？

### 提到我会Docker，说一下Dockerfile你经常用的一些命令？

### 数据库IO是对项目性能影响较大的，能不查数据库就不查，先对参数判断再执行下面的流程

### 在数据库里图片存为访问链接

### 后端接口设计入参要给前端用

### Spring里的entity一般要实现get、set、toString方法

### 使用注解@Slf4j后代码里打印日志用log.info("xxx")、log.error("xxx")等方法

### 按10条分页最后正好剩10条时，前端怎么不显示下一页？

每次多查1条，如果能查到11条后面就还有，只能查出11条以下后就表示没有下一页了

### 部分具体亮点(可以酌情在面试中提出)

1. 小说是否更新爬虫抓取周期，白天15分钟一次，半夜12点到早上6点没30分钟一次，更新集中时间段每3分钟一次
1. **流水插入失败也要能自动重插**，不要让用户又再输入一遍
1. 把所有非法校验抽离出来形成一个方法，用返回值标记校验成功还是失败
1. Controller的接口是对外的，**参数一定要**做比较到位的**校验**，不能能完全依赖前端；Controller一上来**先验证参数**
1. **一般Controller的接口逻辑是独一无二的，Service的逻辑是可复用的**；所以可以先全部写到Controller里面，再把重复的接口逻辑抽离出来放到Service里
1. **Service的方法**入参和返回值**不要是map类型**或**ResponseDO\<Foo\>类型**，别人要用的话还得看map里要哪些参数/返回的map里有哪些参数
1. try catch在商用环境里不要随便用，会捕捉不到报错信息，一般throw
1. 评分、钱......小数 在MySQL数据库可以用**decimal类型**存，不用float
1. 分页接口不要对前端暴露分页的size，分页的size后端一般定死了为几个值(，例如10，20，50，100)，前端选择size的编号即可；若暴露可能导致**前端恶意请求**传入一个大的size分页对数据库破坏；
1. 商业返回要有**明确的错误信息**，不能使用统一的**错误码**，例如400，404，403等，因为这些错误码对用户来说没有意义，用户需要知道具体错误
1. ip在请求头里一查就能查出来
1. 商用代码脚本要审核后才能上线，尽量别使用 MyBatis Plus 不好审核
1. 使用NumberUtil类字符串转数字，String的parseInt()方法会**抛出异常**，而NumberUtil类会**自动处理异常**
1. 方法参数在能用基本类型时尽量用基本类型，不用包装类，传入的参数**一定要判空**

### Spring Controller返回对象：一般BaseResponse\<T\> 有三个字段data、message、code，并有success、error两个抽象方法，Controller返回BaseResponse\<T\>变JSON给前端返回；Controller的参数有默认的HttpServletRequest、HttpServletResponse，还有自己定义的参数

1. **直接返回对象(Foo)**：如果你的API要求简单并且不需要添加任何额外的状态码或者响应头，那么你可以直接返回一个对象。Spring MVC会使用HttpMessageConverter将该对象转换为JSON或XML格式，依据请求中的Accept头部信息。
1. **返回ResponseEntity\<Foo\>**：当你需要控制更详细的响应细节，比如状态码和响应头时，你可以返回ResponseEntity\<Foo\>。ResponseEntity是Spring的一个泛型类，它代表了整个HTTP响应，包括状态码、响应头和响应体。
1. **返回自定义的响应对象(如ResponseDO\<Foo\>或ResponseDO\<Object\>)**：如果你想要一个统一的响应格式，你可能会创建一个自定义的响应对象来封装状态信息、消息和数据。这使得你的API响应具有一致的结构，便于客户端处理。ResponseDO\<Foo\>使用泛型可以**提供类型安全**，而ResponseDO\<Object\>则**可以接受任何类型**的对象作为数据，两者有各自的使用场景。通常，强类型的响应ResponseDO\<Foo\>更受推荐，因为它提供了更好的类型安全和文档表达。当然，ResponseDO\<Object\>在某些情况下也适用，特别是**当返回的数据类型不是固定**的时候。

> 别听校招vip瞎忽悠，代码还没鱼皮懂，可能数据库设计好点
> 上GitHub搜代码，看看顶级开源项目咋写的，乐
> [apache顶级开源项目incubator-seata的代码](https://github.com/apache/incubator-seata/blob/2.x/core/src/main/java/org/apache/seata/core/model/Result.java#L69)，自己按这个学着写就好，Spring里也是用泛型

### Enum枚举类里要有枚举常量、私有字段、一个全参数构造方法(无需无参构造方法)、get、set、最重要的getById方法(处理从数据库只能拿到id的情况，由数据库得到的id获得枚举值)

### Spring 分层，每层当一个模块开发，自己有一个 pom ; Spring 的注解

jar包的入口点是一个main方法，war包的入口点是一个xml文件
Spring内部集成了一个Tomcat再封装了war包，打成jar包可以直接执行(去xml文件)，要调优的话要拆开打出来jar包操作
**不前后端分离**是MVC架构：访问Controller，Controller调用Model查数据，最后展示到View层页面上
**前后端分离**的架构：Controller -> Service -> Model(Spring Boot里叫Mapper)
简洁分层(少了不少东西，每层当一个模块开发，自己有一个pom)：

1. Controller层
    - Controller(xxxController)
1. Service层
    - Service服务实现类(xxxServiceImpl)
1. Interface层
    - Service服务接口(xxxService)
    - Util类(xxxUtil)
    - 枚举(xxxEnum)
    - 常量
1. Model/Mapper层
   - Mapper(xxxMapper)
1. Entity/dto层
    - Entity(entity包里){xxx}
        - 放POJO类，一张数据表对应字段的存放在POJO类中
    - DO(dto包里){xxxDO}
        - 在Java编程语言中，"DO"通常是"Data Object"或"Domain Object"的缩写。它是用于表示从数据存储中得到的数据，通常与数据库表结构对应，用于实现领域模型和业务逻辑。例如，一个用户的DO可能包含用户名、密码和其他个人信息，这些信息直接映射到数据库的用户表。这样的对象主要用于数据访问层（DAO），通过DAO层向上传输数据源对象。简而言之，DO是从现实世界中抽象出来的有形或无形的业务实体

> **默认的固定方法闷头正向写**(Model/Mapper -> Service -> Controller)
> **业务逻辑的方法的反向写**(Controller -> Service -> Model/Mapper)
> 一般业务逻辑校验是判定异常就return或抛错误，这样就只写if不用写else方便

VO、DTO、DO、PO是在软件开发中用于数据处理和传输的不同类别。它们通常用于Java编程语言中，但也可以应用于其他编程语言。这些类别有助于在软件开发中组织和管理数据，确保数据在不同层之间正确传输。下面是它们的简要说明：[介绍的网址](https://blog.csdn.net/tang_seven/article/details/129498249)

1. VO(View Object): 显示层对象，通常是 Web 向模板渲染引擎层传输的对象。值对象，主要用于表示层和控制层之间传输的数据。它通常包含展示给用户的数据。
1. DTO(Data Transfer Object): 数据传输对象，Service 或 Manager 向外传输的对象。数据传输对象，用于不同系统或应用层之间传输数据。它可以包含多个对象的数据，以减少网络请求次数。
1. DO(Data Object) / PO(Persistent Object) / Entity: 与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。数据对象，通常与数据库表结构相对应，用于表示从数据存储中得到的数据。
1. BO(Business Object): 业务对象。由 Service 层输出的封装业务逻辑的对象。
1. AO(Application Object): 应用对象。在 Web 层与 Service 层之间抽象的复用对象模型， 极为贴近展示层，复用度不高。
1. Query: 数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。

Maven的好处是能很好的管理包(管理**共用**jar包)，按分出的几层，**每层**当作**一个模块**(使用一个pom)来开发，主目录放一个父pom管理此**项目**中的每个模块的pom(**每层**)

Spring Boot 分类中 Template Engine(模板引擎)：做前端的
Spring Boot 分类中 Spring Session：分布式Session
Spring Boot 分类中 SQL：引入数据库组件MySQL Driver、Mybatis Framework
Spring Boot 分类中 NoSQL

### 接口的方法要写注释，要Junit写测试

String判空可以用StringUtils工具类
自己写工具类，方法一般都是public static的

```java
String name;
if(StringUtils.isEmpty(name)){
    return null;
}
```

- Java9后处理日期时间用DateTime，[一些用法](https://blog.csdn.net/weixin_38568503/article/details/126692794)
- 在Spring框架中，@Autowired 是根据类型进行注入，而 @Resource注解默认是通过名称来进行依赖注入的。如果没有找到匹配的名称，那么它会退回到类型匹配。这意味着如果你的bean名称不匹配，Spring会尝试按类型来注入相应的bean。这是一个备用选项，以确保如果名称不可用，依赖仍然可以被注入。
@Qualifier注解通常与@Autowired一起使用，@Qualifier能指定名字
- 在Spring框架中，@Data注解是Lombok库的一部分，用于简化实体类的代码。当你在类上使用@Data注解时，它会自动为该类生成getter和setter方法，以及equals、hashCode和toString方法。这样，你就不需要手动编写这些通常是标准的Java代码，从而使得代码更加简洁并减少了潜在的错误。记得要在你的项目中添加Lombok依赖才能使用@Data注解。
- 在Spring框架中，@RestController注解是一个用于创建RESTful Web服务的便捷方式。它是@Controller和@ResponseBody注解的结合体，这意味着它不仅将类标记为Web请求的处理器，同时也确保响应是直接以JSON或XML格式返回给客户端的，而不是导航到一个视图。
- @RequestMapping("/user")在Controller类上就表示这个Controller类所有请求前都加上/user来访问，@PostMapping("/register")、@GetMapping("/getCaptcha")在方法上表示这个方法是POST请求或GET请求，方法参数中的注解 fooFunction(@RequestParam("name") String name)表示这个URL查询参数中的name的值会被自动提取并赋值给方法的name参数，fooFunction(@RequestBody User user)表示这个请求的body中的JSON或XML数据会被自动转换成User对象
- 在Spring框架中，@RequestBody注解用于将HTTP请求的body部分绑定到一个对象上。这通常用于处理POST或PUT请求，其中请求的body包含了需要被转换为Java对象的JSON或XML数据。请求的body中的JSON或XML数据会被自动转换成User对象。
- 在Spring框架中，@RequestParam注解用于从请求的URL查询参数中获取值。这个注解通常用于处理GET请求，其中URL中包含了需要被提取的参数。URL查询参数中的name的值会被自动提取并赋值给方法的name参数
- 在Spring框架中，@Controller注解用于标记在一个类上，使用它标记的类就是一个SpringMvc Controller对象，分发处理器会扫描使用该注解的类的方法，并检测该方法是否使用了@RequestMapping注解。@Controller只是定义了一个控制器类，而使用@RequestMapping注解的方法才是处理请求的处理器。
- 在Spring框架中，@Service注解通常用在Service服务层，主要涉及一些复杂的逻辑，需要用到Dao层。
- 在Spring框架中，@Component是一个通用的注解，可以标注任意类为Spring的组件。如果一个Bean不知道属于哪个层，可以使用@Component注解标注。这个注解通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中
- 在Spring框架中，@Repository注解主要用于标注数据访问层，也就是DAO层的组件。
  - DAO层，也被称为数据访问层，是软件架构中的一部分，主要负责与数据库进行交互。
  - 在实际开发中，DAO层通常会定义为接口，然后提供具体的实现类来完成数据库操作。这样做的好处是，当数据库发生变化时，只需要修改DAO的实现类，而无需修改业务逻辑层的代码。
- 在Spring框架中，@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。

### String 可以设计有占位符的模板

> 用 String.format() 来向模板的占位符里插入数据

%d：表示整数类型（十进制）。
%c：表示单个字符。
%b：表示布尔值。
%f：表示浮点数类型。
%e or %E：表示科学计数法的浮点数类型。
%x or %X：表示十六进制整数。
%o：表示八进制整数。
%t：表示日期/时间值（后面需要跟具体的时间或日期格式指示符例如 %tB 表示 locale-specific 月份名称，%td 表示一月中的日子等）。
%%：表示文字%字符。

```java
String exampleFormat = "Name: %s, Number: %d, Decimal: %.2f, Flag: %b";
String formattedString = String.format(formatExample, name, number, decimal, flag);
```

### POJO类全属性private，只能用get/set操作属性，好处是啥？

1. 可以**监控get/set方法**，看哪里调了，如果分析出**调用次数非常多**，可以考虑做个集群或者把次POJO类分到一个性能更好的地方

### 三次握手时在客户端和服务器端等待对方握手时的状态是啥？明确TCP协议里的标志位的变化？说出在握手过程中每个端的等待状态？

1. 说出在握手过程中每个端的等待状态
1. 明确TCP协议里的标志位的变化

### 记录用户点赞用MySQL就行？

1. 因为这是分两步的，第一步要先记录哪个用户对哪个帖子点了赞(也可以选择不实现此功能)，这个操作是一对一的，此行为每个用户都得分开看，只看一个用户的话就是低频操作，第二步记录帖子的总点赞数，这个操作是多对一的，才是高频操作，可以考虑Redis。
1. 量级不大用户数据还是可以放在MySQL里，而不用放在Redis里，数据库的读写性能差，用户数据经常变怎么优化？
    - 优先对MySQL主从分离，唯一索引
1. 记录**热帖**的总点赞数才用Redis记录并且定时任务同步到MySQL数据库里，因为**热帖**的点赞数是高频操作

### 什么是双属性枚举？为什么要用双属性枚举？

1. [双属性枚举](https://www.jb51.net/article/152261.htm)是指只有两个属性的枚举类型，有一个为数字id，一个为说明字符串，数据库里只用存数字id(例如，分类，权限......等只有固定几类的东西)
    - 类型安全：枚举提供一种类型安全的方式来定义一组固定的值。这可以防止使用无效的值，并在编译时就能发现错误。
    - 代码可读性：枚举使得代码更易于阅读和理解。字符串描述提供了对数字代码的直观解释。
    - 易于维护：将数据和状态的描述集中在枚举里，更改和维护变得容易。只需在一个地方更新即可。
    - 内存高效：在数据库中存储一个整数比存储字符串占用的空间小，这对于提高性能和减少存储需求是有好处的。
    - 代码和数据分离：业务逻辑代码中使用枚举，而数据库中存储枚举的数值，这有助于保持代码的整洁性和数据层的简洁性。
    - 扩展性：如果以后需要添加更多的属性或者状态，枚举提供了一种简单的扩展方式。
1. 对于像分类，用户性别，用户状态，用户权限这种有固定值的字段，使用双属性枚举可以在数据库中只存数字减少空间占用与网络流量消耗(做查询的参数)
1. 枚举的说明字符串就直接在代码里，数据库只存数字
1. 使用双属性枚举，并在代码中同时定义说明字符串和相应的数字，而在数据库中只存储枚举对应的数字，这是一个常见的编程模式。这样做的好处是在数据库里只存储数字可以节省空间，加快数据库操作速度。同时，在代码中保留了可读性很强的字符串，便于开发和维护。
1. 使用**双属性枚举**的方法，枚举说明字符串就直接在代码里，数据库只存数字(能不存文本就不存，文本不好校验参数)，代码中也可以用枚举类**实现**的**getById()**方法**传入一个数字**来**获取**枚举值，**要判断返回值是否为空**
1. 枚举有业务属性，双属性枚举有一个字符串属性(，用来描述具体业务)

### 一个用户有没有注册怎么判断？

1. 数据量小的时候可以用MySQL的**唯一索引**代替**布隆过滤器**
1. 量级极大时才考虑**布隆过滤器**，黑白名单......

### 查标题用模糊查询，查描述用了全文索引，按标签查含单个标签的接口可以用MySQL的FIND_IN_SET函数(只能单个标签)

要查找同时**包含多个特定标签**的数据行，可以用 LIKE 和 AND 操作符。以下是一些可能的方案：

1. 全文搜索索引：某些数据库（如 PostgreSQL、MySQL）支持全文搜索功能。如果您经常需要进行此类查询，使用全文搜索可以提高效率。
1. 正则表达式：使用正则表达式来匹配具有特定模式的行，部分数据库如 PostgreSQL 有这个功能，使用 REGEXP 或类似的函数。
1. 分割成多个列：如果可能，将数据分割到不同的列或者表中，然后使用联接 (JOIN) 来查找同时含有这些标签的行。

### 关掉浏览器重进，依然登录的原因？

1. 前后端分不分离
    - 不分离的话，可以通过cookie/session方案实现；分布式的话，需要解决session的共享
    - 分离的话，一般需要通过前端请求的参数找到对应的Token值
1. 集中式和分散式
    - 集中式是把登录信息放到统一的登录后台系统，前端Token只做映射，不包含用户信息
    - 分散式是Token里面记录用户信息(JWT)，后台只做校验。比较常见
1. 登录Token保存的信息是什么？失效时间怎么处理？([具体看JWT的介绍](https://javaguide.cn/system-design/security/jwt-intro.html))
    1. Token保存的信息
        1. **核心就是userId**，最重要的就是标记一个用户；不可以存密码，JWT存放的信息可直接解析出来
        1. **保证安全性加个签名**，Token在前端，如何保证安全性？
            - 如果**只存放**userId，那别人改一下就可以登录别人的账号了，所以需要对数据进行安全处理：可以**加个签名**
            - 签名**没有信息**，只能验证传递的参数**是否被修改**过，所以JWT传递的参数中需要包含原数据
            - 现在用RSA代替MD5做签名了，MD5不安全
        1. **加个过期时间防Token丢失**，Token如果丢了，是不是账号也丢了？
            - 是的，**加个过期时间**
1. 前后端分离后，有两种选项**离散式Token**和**集中式SSO**(登录一个模块，其他全登录；登出一个模块，其他全登出)？
1. 为避免数据库被意外拖库后泄露用户密码的明文，在数据库中储存用户密码明文加盐值生成出的签名；
    - 但是**可以暴力破解**签名，发现数据库中有许多相同的签名，拿常用密码去试看看有没有一样的，所以让用户设置密码要复杂
    - 盐值(SALT)要经常更新，最好 三个月 ~ 半年 更新一次

### Spring Session + Redis 怎么实现登录？ JWT 怎么实现登录？

1. Spring Session 校验成功后就在 Session 中记录查询出来的登录用户的user信息(可放敏感信息)，下次通过cookie中的sessionid查找到session，并从session中得到登录用户的user信息(若无则没有登录)，用此来判断是否登录
1. JWT 校验成功后返回一个 token 给用户，用户下次发请求时带上此token，服务端校验此token若成功就相当于登录，并可以从token中获取基本信息(不可放敏感信息)
    - 用 JWT 实现登录，要把 user_id 和 user_role 和 过期时间 置于 payload 中

### 为什么使用 JWT 登录 而不用 {Spring Session + Redis}(通过 Redis 实现了*分布式Session*，*避免了*使用*分布式架构*时*用 tomcat 保存 session 时*会出现的用户登录失效的问题) ？单点登录（SSO）？

1. JWT 的有效性无法主动注销用户的已登录状态，只能等待 token 过期，更改密码或点击退出后之前的 token 依然有效 (设置黑名单/Redis 保存 JWT 的状态可以撤销但与 JWT 不在服务端存储状态的理论相违背，变成类似session的东西了)，而 Spring Session + Redis 可以通过修改 Redis 中的 session 数据来主动撤销用户的登录状态 (单点退出后其他服务也一并退出，SSO)方便后续做单点登录 **{自己业务少的时候或只有单一业务不用实现单点登录，没有实现的场景}**
    - 单点登录（SSO）适合在多个应用系统中，只需登录一次就可以访问其他相互信任的应用系统时使用。这种方法提高了用户体验，减少了重复登录的繁琐，特别适用于企业内部网或外部网、学生门户网站、公有云服务等环境。通过单点登录，用户可以在一次登录后访问多个相关应用和服务，无需重复输入凭证，节省时间并提高便利性。然而，需要注意凭证泄露可能带来的安全风险，因此建议结合多因子身份验证（MFA）以增强安全性
1. 适合使用jwt的场景：有效期短 / 只希望被使用一次
    - **建议将 JWT 存放在 localStorage 中，放在 Cookie 中会有 CSRF 风险。**
    - 比如，用户注册后发一封邮件让其激活账户，通常邮件中需要有一个链接，这个链接需要具备以下的特性：能够标识用户，该链接具有时效性（通常只允许几小时之内激活），不能被篡改以激活其他可能的账户，一次性的，等待自然过期即可，无需服务端控制其提前终止。这种场景就适合使用jwt。或文件临时一次性分享下载链接
1. 而由于jwt具有一次性的特性。单点登录和会话管理非常不适合用jwt，如果在服务端部署额外的逻辑存储jwt的状态，那还不如使用session。基于session有很多成熟的框架可以开箱即用，但是用jwt还要自己实现逻辑。
1. 使用session与redis结合，因为单纯的使用session缓存数据的话，当一次会话结束后，session就会消失，如果结合redis使用则不会出现数据失效的情况。
1. JWT (类似身份证)无需在服务端存储 session 信息，不用数据库的查询(仅需存储解密密钥，使用密钥校验)，对跨域友好，可以在不同应用间共享用户信息
1. 用 OAuth 2.0 集成第三方登录 QQ、支付宝、钉钉、GitHub......
1. 使用 SpringSesion 的思路是：除了网关服务，每个服务都引入 SpringSession，使用 redis 实现 session 同步。获取信息时，根据 sessionId 从服务器 session 取，如果没有，连接 redis 服务器获取。
1. 使用 jwt 的话，我们在卡号服务里生成一个 jwtToken，放在 cookie 里，由网关服务解密后放在请求头里，这样的话，所有服务都可以从请求头里获取卡号信息。
1. JWT 只能传输非敏感的人员数据，base64解码后就可以得到json，每次请求都需要在header中携带token信息，增大了带宽的压力
1. JWT (Json Web Token) 分为三部分，header、payload(载荷)、signature(签名)。前后端分离开发模式下，token加密后前端请求服务端获取授权，完成登陆校验，其中我们可以拿到payload中的内容，来回显到前端展示界面
1. session是存在服务端的，他是后端的产物，在前后端不分离场景下，单体应用、分布式架构下都能很好的担任他的角色，特别是有SpringSession这一完美解决方案，将session的令牌存在浏览器cookie中，数据存储在redis；但是在前后端分离流行的当下，特别是微服务架构下，JWT以简洁、易用更能胜任校验状态的角色，JWT更是最流行的跨域认证解决方案，通过加密，载荷也相对安全的存储了用户的信息，前端也更容易拿到这一信息，并把信息存储在localStorge或cookie中

### 前后端分离时使用 {Spring Session + Redis}(*实现分布式Session*)，如果客户端是 手机app/小程序 等非浏览器，没有cookie实现保存不了cookie怎么办？

1. Spring Session **默认**使用 **cookie** 保存sessionid (对**浏览器**方便)，如果客户端是 **手机app/小程序** 等**非浏览器**，**没有**cookie实现**保存不了**cookie就不能通过cookie来访问session对象，需要在登录成功后，将sessionid添加到响应数据中，**保存在客户端**，下次用户访问，就在请求头当中带上sessionid ; 用 Spring Session 中的 ```HeaderHttpSessionIdResolver``` 实现
1. 用 Spring Session 中的 ```HeaderHttpSessionIdResolver``` 实现时，当会话被创建时，HTTP响应会包含一个指定名称的响应头和会话ID的值。例如，响应头可能如下所示：```X-Auth-Token: f81d4fae-7dec-11d0-a765-00a0c91e6bf6``` 客户端在每个请求中应该通过指定相同的头来包含会话ID。当会话被下线无效时，服务器将发送一个带有相同头名称但值为空的HTTP响应
1. 确保会话ID被改后用户不会登录成别人：
    - 使用安全的会话管理机制：确保在用户登录认证成功后，将用户的登录凭证放入会话中进行管理
        - 例如，会话代替方案：考虑采用会话代替方案，如使用单次令牌或其他安全机制来代替传统的会话ID
    - 注意会话ID的安全性：尽量避免会话ID泄露给他人，以防止他人伪造请求。通过HTTPS协议传输会话ID可以加密通信内容
    - 定期更新会话ID：定期更新会话ID可以增加安全性，减少被猜测或利用的可能性
    - 限制会话ID的有效期：设置会话ID的有效期，当超过一定时间后自动失效，减少被滥用的风险
    - 实施防护措施：考虑使用防护机制如防止会话固定攻击和跨站请求伪造等安全措施来保护会话安全

### 搜索如何实现主库从库的分离？分离的数据同步是怎么实现的？搜索的质量和性能？怎么样怎么能够去多姿段查询？搜索的字段维度？

### 后端数据库里储存什么值来让前端判断渲染权限对应的界面(无权限的页面、按钮...... 隐藏)？

> 在数据库设计中，通常并不直接存放与前端按钮可见性或交互性相关的信息。这些通常是前端应用的实现细节。数据库层面关心的是数据的结构和完整性，而对如何展示或使用这些数据并不涉及。前端的可见性和可交互性通常是**基于用户的角色和权限**来决定的。(例如，我用的Vue/React框架)

1. 目前前端通过 ```loginUser.userRole``` 的函数获取数据库中 ```userRole``` 字段的值来判断渲染 user/admin 权限对应的界面(没权限的不渲染，隐藏)
1. 所以修改 ```userRole``` 字段类型为 ```tinyint``` 的话，前端通过 ```loginUser.userRole``` 的函数获取到的值就是 ```tinyint``` 类型的，前端判断权限的语句得改

**不过**，如果你需要后端控制前端按钮的显示与否，你可以在数据库中设置相关的权限控制表。例如：

1. 用户角色表：定义了可用的角色。
1. 权限表：定义了不同的权限，每个权限对应**前端界面**上的一个或多个**元素**，**如按钮**。
1. 用户角色权限关联表：标识每个角色拥有的权限。

这样前端应用可以根据用户的角色和关联的权限动态地显示或隐藏按钮，或设置其为不可点击状态。例如：

1. 当用户登录时，前端应用会查询数据库或通过API获取后端数据库用户角色字段。前端根据用户角色字段，决定渲染什么权限的字段
1. 是否渲染特定的按钮或将其设置为不可用状态或更改描述。如管理员点击封禁用户并且用户状态变成封禁后，前端原本显示封禁的按钮要变成显示解封，前端可以通过API查询后端数据库用户状态字段，通过字段值判断怎么渲染

> 某些客户端**框架**可能会在渲染**之前**将权限数据用作渲染决策的**依据**。(例如，我用的Vue/React)
> **请注意**，即使前端隐藏了按钮，逻辑仍然应该在后端进行验证，以确保没有权限的用户不能通过直接调用API等方式执行不被允许的操作。始终在服务端进行权限检查是保护应用安全的重要措施。

### 类的变量加static和不加的区别是什么？是不是所有变量都要加static？

1. 存储位置和生命周期：
    - Static变量：也称为静态变量，它是类的一个类变量，不属于类的任何一个实例。静态变量在类被加载时创建，在程序结束时销毁。无论你创建了类的多少实例，都只有一份静态变量的副本。
    - 非Static变量：也称为实例变量，它属于类的一个实例。每当你创建类的新实例时，都会为非静态变量创建新的副本，且每个实例的非静态变量都是独立的。
2. 访问方式：
    - Static变量：可以不创建类的实例就直接通过类名访问。
    - 非Static变量：必须创建类的实例才能访问。
3. 内存管理：
    - Static变量：既然它们只有一份副本，静态变量被所有实例共享，所以它们是一种节约内存的方式，当你的变量值应该在类的所有实例之间共享时。
    - 非Static变量：每个实例有自己的变量副本，因此它们不共享状态，可能会占用更多的内存。
4. 默认值：
    - Static变量：如果未显式初始化，它们会获得类型的默认值（例如，int的默认值是0，对象引用的默认值是null）。
    - 非Static变量：同样未初始化时，也会获得类型的默认值。

> 是否所有变量都应该加上static取决于你的具体需求：
> 如果某个变量应该跨所有实例共享，比如常量、```serialVersionUID```、配置信息、状态标记或者计数器，那么它应该声明为static。
> 如果每个实例都应该拥有自己的变量副本，如对象的属性或者状态，那么它就不应该是static。
> 滥用static会导致设计上的问题，比如对于那些应该是实例独有的属性，如果进行了static声明，就会引起不必要的数据共享，可能会引发安全问题或是逻辑上的错误。因此，不是所有变量都适合加上static。

### MySQL怎么分页？

```sql
SELECT * FROM table_name LIMIT offset, count;
```

> 其中，```table_name```为要查询的表名；```offset```指定从第几条记录开始返回结果（索引值从0开始）；```count```指定每次返回多少条记录。

可以用 ```WHERE type != 0``` 这种限制条件，查全部分类的条目。**动态多条件**查询，例如Mybatis的mapper的xml中写：

```sql
WHERE
Status !=0 
<if test="sort == 1">
    ORDER BY AddTime desc
</if>
<if test="sort == 2">
    ORDER BY SubscribeNum desc
</if>
limit #{offset},#{size}
```

### 项目的架构你是怎么设计的？(简历别写分布式相关的，面试聊想法时可回答)

> - [ ] 简历上的项目不写网关、RPC、消息队列、分布式，但面试时讨论优化点可以讲；3、为保证接口服务的可用性和稳定性，接口服务被独立部署在一台机器上。为了隐藏接口服务的真实地址和端口，避免接口服务被恶意攻击，前端请求先发送给网关，网关鉴权后再路由转发给接口服务处理；4、为了避免在网关中引入数据库操作，提高服务的可维护性，用Dubbo RPC实现服务间的方法远程调用；

1. 我采用**前后端分离**的架构，**前端 Ant Design Pro 使用Nginx部署**，通过**Nginx 反向代理**将请求转发到 web 项目(**注意通过反向代理这句话不一定对，我在 Ant Design Pro 打包生成的前端没用上**)，因为项目刚刚上线，所以这里暂时采用了单机部署的模式，未来可能采取水平扩容的方式，增加多台节点，通过**Nginx 的负载均衡**，将请求平均的分发到我的每个节点上，以支撑更高的并发。
1. 我的 web 项目使用**Spring Boot**开发，并连接到了数据库和 Redis，数据库使用的是 MySQL，主要用来存储用户的信息和接口的信息；~~通过 Redis 实现了**分布式 session**，因为考虑到未来要使用分布式架构，为了避免使用 tomcat 保存 session 有用户登录失效的问题。~~

> 注：这里我说出了**反向代理，水平扩容，负载均衡**等技术名词，很多面试官会根据这些名词进行延伸提问（引导面试官往自己熟悉的东西上提问）比如：**说说什么是正向代理/反向代理？什么是水平扩容？什么是负载均衡？你了解哪些负载均衡的算法？**提前准备好这些知识之后，就可以跟面试官一顿输出了。

### 你怎么做的技术选型？为什么要用这些技术？(简历别写分布式相关的，面试聊想法时可回答)

> - [ ] 简历上的项目不写网关、RPC、消息队列、分布式，但面试时讨论优化点可以讲；3、为保证接口服务的可用性和稳定性，接口服务被独立部署在一台机器上。为了隐藏接口服务的真实地址和端口，避免接口服务被恶意攻击，前端请求先发送给网关，网关鉴权后再路由转发给接口服务处理；4、为了避免在网关中引入数据库操作，提高服务的可维护性，用Dubbo RPC实现服务间的方法远程调用；

1. 使用 SpringBoot 是因为通过**自动装配**能够提高项目的开发效率，还能够很好的**整合其他服务**。
1. 使用 MySQL 的原因是因为考虑到未来有用户充值交易，限制调用次数等场景需要**用事务保证数据的完整性和一致性**。
1. 使用 Redis 的原因是因为可以用来实现**分布式 session、缓存**等功能。因为 Redis 是一个单独的中间件，不同客户端可以往同一个 Redis 或者集群中存放session/缓存，这样就能**保证资源能够在分布式服务下都可见**。
1. 并且由于**Redis 也是单线程**的，同时也**支持 lua 脚本**，可以保证并发安全的问题，所以可以很简单的实现分布式锁的功能。(**简历别写分布式，面试聊想法时可回答**)

> 注：被面试官追问自动装配的原理你了解过吗？自动装配是怎么实现的？分布式 session 的原理？

### 为什么你要使用网关？Spring Cloud Gateway网关有什么用？

> - [ ] 简历上的项目不写网关、RPC、消息队列、分布式，但面试时讨论优化点可以讲；3、为保证接口服务的可用性和稳定性，接口服务被独立部署在一台机器上。为了隐藏接口服务的真实地址和端口，避免接口服务被恶意攻击，前端请求先发送给网关，网关鉴权后再路由转发给接口服务处理；4、为了避免在网关中引入数据库操作，提高服务的可维护性，用Dubbo RPC实现服务间的方法远程调用；

1. [见链接](https://javaguide.cn/distributed-system/api-gateway.html)
1. 我这个平台的关键点就在于**提供接口服务**，要保证接口的**可用性和稳定性**，所以将接口服务独立部署在另一台机器上，**隐藏真实的接口地址及端口**，调用接口服务的请求都必须经过**网关流量染色**之后...... **(这里细节太多，比如 rpc 调用获取用户sk，重新生成签名认证等等)** 之后，将请求转发到真实的接口地址(**网关就是个代理**)，防止接口被恶意调用、盗刷。(知道了真实地址和端口还可以DDOS攻击)
1. 有网关后，前端抓包就只能发现请求的是网关地址，只能得到网关的真实地址，接口服务的真实地址无法得到。

> 注：**这个问题要对网关做了什么事情非常非常熟悉，建议反复观看鱼皮**大佬的直播回放。

### 为什么使用 RPC 调用？有了解过其他的方式吗？

> - [ ] 简历上的项目不写网关、RPC、消息队列、分布式，但面试时讨论优化点可以讲；3、为保证接口服务的可用性和稳定性，接口服务被独立部署在一台机器上。为了隐藏接口服务的真实地址和端口，避免接口服务被恶意攻击，前端请求先发送给网关，网关鉴权后再路由转发给接口服务处理；4、为了避免在网关中引入数据库操作，提高服务的可维护性，用Dubbo RPC实现服务间的方法远程调用；

1. 因为如果在网关引入数据库的操作的话，不仅会增加项目体积，还违背了设计原则的**单一职责原则**降低了系统的可维护性，所以我考虑通过服务间调用的方式，我了解过有两种方式，第一种是**Open feign**，原理是构造了一个 HTTP 请求，并会添加很多的请求头，body 是使用 json 字符串传输，所以调用效率会比较低，更加适合外部服务间的调用。
1. 然后我了解到**RPC**是可以基于 TCP 协议，避免了无用的请求头，以及可以通过**将数据序列化为二进制流的形式传输，效率更加高效，更加安全**，所以更适用于我这个场景。最终我选择了 Dubbo RPC 框架来实现这个功能。

### 你的接口调用次数统计以及排行是怎么实现的？可以做接口热度的排行榜，排行榜变动时的性能压力，怎么优化解决？

> - [ ] 简历上的项目不写网关、RPC、消息队列、分布式，但面试时讨论优化点可以讲；3、为保证接口服务的可用性和稳定性，接口服务被独立部署在一台机器上。为了隐藏接口服务的真实地址和端口，避免接口服务被恶意攻击，前端请求先发送给网关，网关鉴权后再路由转发给接口服务处理；4、为了避免在网关中引入数据库操作，提高服务的可维护性，用Dubbo RPC实现服务间的方法远程调用；

答：通过 MySQL 统计，每次调用结束后，~~网关都会发起一个 rpc 请求~~，调用次数+1。

> 注：这里我**会抛出一个设计缺陷**，在实际测试过程中，通过 jmeter 压测工具，会出现调用次数不准的情况，原因是因为没有在业务层面加锁，导致数据库出现并发写的问题。并且并发量大的话，对数据库造成很大的压力。**引导面试官问出**，那你有什么更好的解决方案吗？

1. 等调用完api接口并成功返回后才让数据库中的统计数据加1，容易形成并发写(MySQL写入时加写锁)，用Redis代替MySQL
1. 如果在业务层面加一个写锁的话，会影响业务的执行效率，所以我想使用 Redis 去解决，Redis 有一个数据结构 Zset 支持排序，**score 可以用来存储调用次数**，并且 Redis 是单线程，可以解决并发问题。
**如果用 MySQL** 实现接口热度排行榜，每次生成接口热度排行榜时，取出数据后还需要对数据**排序**，**排行榜更新变动**时的**性能压力大**

> 注：这里被追问过 Zset 的底层实现，以及**如何将这些数据进行持久化保存**，防止 Redis 宕机导致数据丢失，可以从 **AOF，RDB** 展开来讲，或者在后台开启一个**定时任务**，定时**每分钟**将这些数据进行**落库**。

### 你做过什么优化吗？你接口的性能怎么样？

答：我有一个接口是随机返回土味情话，我在数据库中插入了几千条土味情话，当调用接口时随机返回一条。
在还没有优化前，**接口的 qps 在 300**左右，但是考虑到这个接口只有读操作，没有增删改操作，所以我将这张表的存储引擎从 Innodb 改为了 MyISAM，接口的**qps 提升到了 1500**。

> 注：被面试官追问为什么改为 MyISAM 有这么大的性能提升？Innodb 和 MyISAM 有什么区别？
> 这个问题一定要根据自己实际情况来答，根据自己擅长的方面，比如对查询语句做了索引优化，提升了接口的性能。

### Spring 常用方法与注解？

1. [见链接](https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html)
1. Spring **@Scheduled任务**它默认有一个线程池大小为1的线程池，**Controller方法默认多线程并发**，或者@Async注解标记异步实现的方法也是多线程并发
1. @PostConstruct是Java自带的注解，在方法上加该注解会在项目启动的时候执行该方法，也可以理解为在spring容器初始化的时候执行该方法，可作为一些数据的常规化加载，比如数据字典之类的。
1. @SpringBootApplication 包含 @ComponentScan 默认扫描配置类所在目录下的所有包(以配置类所在目录为根目录) 还要扫描别的位置的话，需要自己在注解里写明

### 涉及浮点运算或钱时使用BigDecimal计算小数

1. [具体注意事项见链接](https://javaguide.cn/java/basis/bigdecimal.html)

### ~~怎么实现在Spring Boot中配置多个邮箱(spring-boot-starter-mail默认只支持单个邮箱)？~~

> - [x] 简历已经描述为配置了自己的私有邮箱服务器，以后流量大了就不用免费邮箱，用自己的域名和服务器搭建邮箱服务，到时候多邮箱功能就只用于让用户识别邮件是什么服务发来的。

1. [见链接](https://blog.csdn.net/u012110298/article/details/106786456/)
1. spring-boot-starter-mail会根据spring.mail.xxx相关配置对JavaMailSender进行自动配置。但是**只支持单个邮箱**。为了**实现多邮件源**，可以参照上述逻辑。在配置文件内配置好，多个邮件源。然后读取配置文件，手动对JavaMailSender进行配置，并将其初始化完毕的JavaMailSender存储容器内。然后发送时随机取出JavaMailSender进行发送。
1. 定义配置属性：使用@ConfigurationProperties注解定义配置属性类，这样您可以在应用程序的配置文件（例如 ```application.yml``` 或 ```application.properties```）中保持多个邮箱配置。
1. 创建配置类：创建一个配置类，通过在该类上使用@Configuration注解，并通过@Bean为每个邮箱创建一个邮件发送器（JavaMailSender）实例。
1. 注入和使用：在您的服务或组件中，需要发送邮件时，注入对应的JavaMailSender实例，并使用它来发送邮件。
1. 如果你想要在发送邮件时轮流使用多个邮箱账户，可以通过在JavaMailSender上封装一个服务来管理邮箱账户的选择。下面的示例会展示一个简单的轮流切换邮箱账户来发送邮件的服务。
    - 所有的JavaMailSender实例都在构造函数中通过依赖注入注入到一个列表中。在sendEmail方法中，每次调用都会通过getNextMailSender方法来获取下一个JavaMailSender实例。
    - **不一定要**用 ```AtomicInteger``` Spring Boot默认单线程，但Controller方法默认多线程并发，或者@Async注解标记异步实现的方法也是多线程并发
    - **这里使用了 ```AtomicInteger``` 来保证索引的线程安全性**，```java.util.concurrent.atomic.AtomicInteger```。 AtomicInteger 是依靠 **[volatile](https://blog.csdn.net/u013967628/article/details/85291748)** 和 **CAS** 来保证原子性的

```java
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

@Service
public class RoundRobinEmailService {

    private final List<JavaMailSender> mailSenders;
    private final AtomicInteger index = new AtomicInteger(0);

    // 通过构造器注入所有的 JavaMailSender 实例
    public RoundRobinEmailService(List<JavaMailSender> mailSenders) {
        this.mailSenders = mailSenders;
    }

    private JavaMailSender getNextMailSender() {
        // 获取下一个 JavaMailSender 实例（在列表中轮流进行）
        return mailSenders.get(index.getAndUpdate(i -> (i + 1) % mailSenders.size()));
    }

    public void sendEmail(String to, String subject, String text) {
        JavaMailSender mailSender = getNextMailSender();
        // 创建并发送邮件...
        // MimeMessage message = mailSender.createMimeMessage();
        // MimeMessageHelper helper = new MimeMessageHelper(message, true);
        // helper.setTo(to);
        // helper.setSubject(subject);
        // helper.setText(text, true);
        // mailSender.send(message);

        // 打印日志或执行其他需要的逻辑
        System.out.println("邮件已通过邮箱 " + ((JavaMailSenderImpl)mailSender).getUsername() + " 发送");
    }
}
```

### 邮件验证码绑定邮箱或登录怎么使用 Redis缓存 实现？

> 生成的验证码放在Redis缓存中并设定**30分钟**的**过期**时间，用 **CAPTCHA_CACHE_KEY(Redis 验证码存储类的key抬头，例如"api:captcha:") + 邮箱地址** 做 Redis 的key保证**只有最新的验证码有效**(，每次生成后存储验证码到value时因为key相同所以会覆盖之前的value)
> 用邮箱登录时，若验证成功后若发现邮箱没在MySQL数据库里，可以将跳转到注册页面，让用户注册一个新账号。

1. 验证码输入错误**次数限制**，比如设置短信验证码输入错误3次后，这个短信验证码就不能使用了。防止猜测短信验证码恶意注册。若**没有保护**则可能：
    - 用户在登录界面填写手机号，不获取短信验证码，直接通过爆破模块(burp suite)，生成一堆的验证码，直接脚本批量尝试登录。
    - 重置密码的逻辑，同样也可以通过这种爆破验证码的逻辑，跳过短信验证码，直接修改密码。
1. 为了防止资源浪费和安全，一旦用户通过验证码验证了邮箱，您应该**立即移除验证码**使其**失效**。
1. [验证码防爆破链接](https://blog.csdn.net/lilei1138494584/article/details/126637447)

### 邮件激活链接绑定邮箱或改密码 或 文件临时一次性分享下载链接 怎么使用 JWT 实现？

> **适合使用jwt的场景**：有效期短 / 只希望被使用一次
> 比如，用户注册后发一封邮件让其激活账户，通常邮件中需要有一个链接，这个链接需要具备以下的特性：能够标识用户，该链接具有时效性（通常只允许几小时之内激活），不能被篡改以激活其他可能的账户，一次性的，等待自然过期即可，无需服务端控制其提前终止。这种场景就适合使用jwt。或文件临时一次性分享下载链接

1. [JWT介绍和基本信息](https://javaguide.cn/system-design/security/jwt-intro.html)
1. 实现JWT的时候，SECRET_KEY 是用于对JWT签名的密钥，它必须保持私密性。选择将 SECRET_KEY 存储在哪里通常取决于你的应用程序的需求和安全的最佳实践。以下是几种常见的存储方式：
    - **配置文件**：将 SECRET_KEY 存储在服务器的配置文件中是**比较常见**的做法。为了安全起见，配置文件不应该被包含在版本控制系统中，而是应该在部署的时候通过安全的方式（如使用配置管理工具）添加到应用程序环境中。这种方法对于不需要频繁更改密钥的应用程序来说，既安全又方便。
    - 环境变量：另一种方式是将 SECRET_KEY 存储为环境变量。这意味着密钥直接存储在应用程序运行环境中，这使得更改和管理密钥更加方便。它不会直接暴露在代码或配置文件中，提高了安全性。
    - 密钥管理服务：对于需要更高安全性的系统，可以使用密钥管理服务，如AWS KMS（Key Management Service）等。这些服务通常提供了密钥的存储、轮换和审计的能力。
    - **数据库/缓存系统**：在某些情况下，你也可以将 SECRET_KEY 存储在数据库或缓存系统（如Redis）中，尤其是当你有**一组密钥需要管理**，或者**需要定期更换密钥时**。不过，这种方法可能需要更复杂的管理和额外的安全措施，以确保密钥存储的安全。
    - 不管选择哪种存储方法，都需要确保对SECRET_KEY 的访问受到适当保护，以防止未经授权的访问。另外，密钥**不应该硬编码**在代码中，以**避免在代码库中无意中暴露**它。请根据应用程序的安全需求和可用的基础设施来选择最合适的密钥存储方案。
1. 我将用于对JWT签名的密钥 SECRET_KEY 放在**配置文件**里以后分布式可能还可以放到**配置中心**去
1. 要把 **user_id** 和 **过期时间** 置于 payload 中(用户名在JWT中可以放到 payload 中携带，但敏感的密码不可以放到 payload 中)
1. 点击链接后如果是**绑定邮箱**，要让用户**输入密码**(**防止输入错误的邮箱发给别人，别人一点击就绑定上错误的邮箱了**)，点击链接**注册**或**改密码**时可以不怕发错邮箱(，因为绑定邮箱时已经验证过邮箱了)点进去输要改的密码就好
1. **要实现邮箱激活链接跳转**
    1. 用户注册时，服务器创建一个包含用户信息（通常是用户ID）的JWT，并设置过期时间。
    1. 为了分辨链接是用来实现 激活邮箱/改密码/...... 不同功能的，在JWT中添加type字段实现了识别不同功能，可以让不同功能的链接重定向到不同功能所需使用的对应页面
    1. 创建一个**包含JWT的激活链接**，并发送到用户提供的邮箱地址。
    1. 用户点击邮件中的链接，请求发送到服务器的**特定端点**。
    1. 服务器**端点解析JWT**，**验证其有效性**，如果有效，激活用户的邮箱，并可能**重定向**用户到登录页面或其他确认页面。

```yml
jwt:
  secret: YourJWTSecretKey
app:
  url: http://yourapp.com
```

用户注册和发送激活邮件的服务组件：

```java
@Service
public class UserService {

    @Value("${jwt.secret}")
    private String jwtSecret;

    @Value("${app.url}")
    private String appUrl;

    // ... 其他服务方法 ...

    public void registerUser(User user) {
        // 保存用户信息到数据库，设置邮箱未激活
        // userRepository.save(user);

        // 生成JWT
        String token = Jwts.builder()
                .setSubject(String.valueOf(user.getId()))
                .setExpiration(new Date(System.currentTimeMillis() + 86400000)) // 设置24小时过期
                .signWith(SignatureAlgorithm.HS512, jwtSecret)
                .compact();

        // 创建激活链接
        String activationLink = appUrl + "/activate?token=" + token;

        // 发送激活邮件，您需要配置邮件服务
        // emailService.sendActivationEmail(user.getEmail(), activationLink);
    }
}
```

控制器方法处理激活请求：(包含链接跳转，重定向)

```java
@RestController
public class ActivationController {

    @Value("${jwt.secret}")
    private String jwtSecret;

    @Autowired
    private UserRepository userRepository;

    @GetMapping("/activate")
    public RedirectView activateAccount(@RequestParam String token) {
        String result = "Activation link expired.";
        try {
            Claims claims = Jwts.parser()
                    .setSigningKey(jwtSecret)
                    .parseClaimsJws(token)
                    .getBody();

            Long userId = Long.parseLong(claims.getSubject());
            User user = userRepository.findById(userId);
            if (user != null) {
                user.setActive(true);
                userRepository.save(user);
                result = "Account activated successfully.";
            } else {
                result = "Invalid activation link.";
            }
        } catch (ExpiredJwtException e) {
            result = "Activation link expired.";
        } catch (Exception e) {
            result = "Invalid activation link.";
        }
        // 假设每种激活状态你都有一个对应的前端页面来表示不同的结果
        String redirectUrl = "/activation-status"; // 根据实际情况修改
        
        // 链接跳转
        RedirectView redirectView = new RedirectView();
        redirectView.setUrl(redirectUrl); // 可以是相对路径或绝对路径
        return redirectView;
    }
}
```

### 发送验证邮件的接口怎么限流(例如，同邮箱1小时内只能发送5次验证邮件，同用户1小时内只能发送10次验证邮件，发送间隔至少1分钟)？前端限流，后端怎么使用 Redis缓存 实现？

1. 直接封IP是不可取的，现在中国大内网，误封一大片
1. 判断**同用户**限流，如何准确识别为**同一个用户**发的请求？
    1. **用cookie识别**跟踪用户，判断是否为同一个用户在请求手机短信验证码：
        - 在实现短信验证码功能时，可以通过设置cookie并创建session来记录用户的请求状态，以此来**限制同一个用户在短时间内重复请求**验证码。例如，服务器可以在发送验证码后，在session中记录下这个行为，并设置一个时间窗口，在这个时间窗口内不再重复发送验证码给同一个用户；sessioon可以放在Redis中，**这样即使用户关闭了浏览器，也能通过cookie来识别用户。**
    1. 如果**移动端没有cookie**，还有**其他方法**可以识别和跟踪用户：
        - 本地存储：使用Web存储API，如**localStorage**代替cookie，来在用户设备上存储信息。
        - 设备指纹：通过收集设备的特定信息（如操作系统、浏览器版本、字体列表等）来生成一个独特的标识符
        - URL重写：将会话ID附加到URL中，通过URL来传递和管理会话状态
        - 移动设备ID：使用移动设备的唯一标识符，如广告ID或设备ID。例如，对于Android应用，可以使用**SharedPreferences**来存储用户的唯一标识符（如UID），这样即使没有cookie，也可以在后续的请求中识别用户
        - 用户账号系统：要求用户登录，通过账号来跟踪用户状态。
1. 后端限流，防止抓取到发送验证码的接口后构造请求恶意攻击
    1. [限制的方法](https://blog.csdn.net/TM007_/article/details/132964854)
    1. **同邮箱**限流，用 **SEND_LIMIT_EMAIL_KEY(Redis 存储类的key抬头，例如"api:send:limit:email:") + 邮箱地址** 做 Redis 的key，设定1小时的过期时间，value存储已发次数
    1. **同邮箱**限流，发送间隔至少1分钟(做时间间隔限制，时间未到**不发**送邮件/短信)，也可以类似的用Redis实现 {还是使用设定过期时间的方法} 或者 {value存储上一次发送时间，判断当前时间与上一次发送时间间隔是否大于1分钟}
1. 为了防范恶意攻击，通常会对发送验证邮件的次数和间隔做出限制。这些限制可以具体包括：
    - 时间间隔限制：要求两次发送邮件之间必须等待一定的时间，比如1分钟。
    - 次数限制：在一定时间周期内，比如24小时内，限制发送邮件的次数，例如最多5次。
    - 验证尝试限制：限制用户在一个时间周期内尝试验证的次数。
1. 实现这些限制的方法如下：
    - 使用缓存（如Redis）来存储有关用户请求发送邮件的信息。您可以将用户的唯一标识（如邮箱地址）与上一次发送邮件的时间戳和当天发送邮件的次数相关联。
    - 在用户请求发送邮件时，检查缓存中的时间戳和发送计数。如果请求与上一次请求的时间间隔太短或当天请求次数过多，则拒绝操作。
    - 当邮件被成功发送时，更新缓存中的时间戳和发送计数。
    - 为了防止资源浪费，一旦邮件发送成功，并且用户通过点击激活链接来验证了邮箱，您应该重置或移除相关的限制信息。
1. 前端页面限流，防止用户连续点击(可能无恶意){前端做**倒计时限制**，时间未到**不能点击**发送短信按钮}
1. **增加图形验证或滑块验证或第三方验证**：发送短信/邮件验证码前，要求验证，
    - ​验证码，比较常用的**图形验证码**或者**滑块验证**或者引入 谷歌/AWS/网易/......**第三方** 的验证，对比说说**它们之间的性能差别或者功能差别**。
        1. **图形验证码(容易被ORC破解)**，每个图片验证码**仅能使用1次**，使用1次后，**不管输入的图片验证码是否正确自动失效**。如果输入错误更新图片验证码。图片验证码失效可以防止图片验证码识别软件尝试多次识别，用户通常需要识别图中的文字或图像，是最基本的验证形式，但可能**因为图像扭曲或噪声**而**难以读取**。它主要抵抗简单的自动攻击。
        1. 滑块验证：用户需要拖动一个滑块完成一定的轨迹或拼合图像，以证明操作者非自动化脚本。相较于图形验证码更为用户友好，但技术**更容易受到模仿攻击**。
        1. 谷歌 reCAPTCHA：这是一种较为高级的服务，能够通过分析用户和浏览器的行为来自动确定是否通过验证，通常对用户透明。reCAPTCHA 的 v3 版本甚至完全不打扰用户。但其存在的问题可能包括影响用户隐私。
        1. AWS WAF 和 Shield：主要是AWS提供的服务，不仅限于CAPTCHA功能，还包括整体的网络应用防火墙服务。比起传统的CAPTCHA提供更全面的安全解决方案，但可能成本更高。
        1. 网易：中国的服务提供商，其验证码解决方案被许多中国网站采用。为了适应中国内地的一些特定要求和互联网环境，网易的服务可能在本地化和语言支持方面更胜一筹。
1. **上行短信验证码**：对于可疑用户要求其主动发短信。
1. 如果攻击者拿多用户同时申请，DDOS可以考虑**购买高防服务**，接上僵尸网络识别功能，对可能已经成肉鸡的IP进行封禁。
1. [链接](https://blog.csdn.net/zengdeqing2012/article/details/79625477)

### 签名和加密有啥区别？MD5签名认证怎么实现的？怎么防止请求头被篡改？怎么防止重放攻击？

1. 签名是不可逆的，不存储原数据，只能做签名验证 ; 加密是可逆的，能够解密
1. 为防止重放攻击，加上了timestamp字段
1. 在数据库里的 **登录密码** 不用 **明文** 保存，保存用**MD5**算法对 **明文密码+盐值** 数据生成的 **签名**，网页表单Post提交用户输入的密码，将 **提交的密码加上盐值** 后用MD5生成签名，把生成的签名与保存在数据库里的签名对比，相同则登录成功
**登录密码** 通过网络传输了，而 **secret_key** 不通过网络传输，所以在数据库中是否保存明文、用于校验合法的方法...... 对于 **登录密码** 和 **secret_key** 使用的设计不一样
1. MD5签名没有信息所以传输时参数要包含原数据(Base64编码包裹传输)，例如access_key(方便服务器通过access_key查到secret_key)、timestamp......(请求头字段，但密钥secret_key别放在请求头明文传输)，secret_key包含在生成并传递过来的MD5签名中了 ; 服务器通过access_key查到secret_key用secret_key再加上**请求头的JSON**作为参数进行MD5签名与传递来的MD5签名对比，相同则签名验证通过(secret_key正确)
    - 为防止请求头被篡改：使用**请求头的JSON**加上**secret_key**一起签名，保证请求头没被篡改
1. MD5秒传(提取文件签名，对比签名，相同 {认为文件一致} 则秒传)
1. **RSA**也可用于签名，**MD5**不够安全

### 登录时怎么保护通过POST在网络上传递的账号密码明文数据安全？其与使用access_key和secret_key签名验证的网关接口服务有啥区别？Spring Boot中怎样将HTTP请求自动重定向到HTTPS请求？

1. Spring Boot使用HTTPS保证POST请求中传递的密码安全 ; 签名验证的网关接口有防重放保护，请求时secret_key不在网络上传递，无论使用的是 HTTP 还是 HTTPS 都能保证安全
1. Spring Boot配置SSL证书开启HTTPS请求，并将HTTP请求转换成HTTPS请求。用acme.sh脚本自动申请泛域名SSL证书，并自动续期(见**科学上网收藏夹**中申请SSL证书的步骤)【生成证书前必须将认证服务设置为letsencrypt（Let's Encrypt）】
    - [Spring Boot配置步骤见链接](https://blog.csdn.net/qq_42347616/article/details/120653643)
    - 生成SSL证书 — 你需要为你的应用生成SSL证书。你可以使用Java的keytool或者Let's Encrypt等服务来生成一个自签名的SSL证书。
    - 配置SpringBoot以使用SSL证书 — 一旦你拥有了SSL证书，需要将它配置到SpringBoot应用中。这通常需要在你的 ```application.properties``` 或 ```application.yml``` 文件中设置相关的SSL属性。
    - 在Spring Boot应用中配置Connector进行HTTP到HTTPS的重定向，创建一个新的配置类来添加额外的Connector：(代码见下)

```yml
server:
  port: 8080 ## 后台服务对外端口
  ssl:
    key-store: server.keystore ##秘钥库文件名称，即上面生成的自签名证书
    key-store-password: 123456 ## 生成秘钥库文件的密码
    key-store-type: JKS ## 秘钥库类型（JKS为jdk的keytool工具默认生成的秘钥库类型）
    key-alias: tomcat ## 秘钥别名
    enabled: true
```

```java
    import org.apache.catalina.connector.Connector;
    import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;
    import org.springframework.boot.web.servlet.server.ServletWebServerFactory;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    
    @Configuration
    public class ServerConfig {
    
        @Bean
        public ServletWebServerFactory servletContainer() {
            TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory() {
                @Override
                protected void postProcessContext(Context context) {
                    SecurityConstraint securityConstraint = new SecurityConstraint();
                    securityConstraint.setUserConstraint("CONFIDENTIAL");
                    SecurityCollection collection = new SecurityCollection();
                    collection.addPattern("/*");
                    securityConstraint.addCollection(collection);
                    context.addConstraint(securityConstraint);
                }
            };
            tomcat.addAdditionalTomcatConnectors(redirectConnector());
            return tomcat;
        }
        
        private Connector redirectConnector() {
            Connector connector = new Connector("org.apache.coyote.http11.Http11NioProtocol");
            connector.setScheme("http");
            connector.setPort(8080); // 这是HTTP端口
            connector.setSecure(false);
            connector.setRedirectPort(8443); // 这是在上面配置的HTTPS端口
            return connector;
        }
    }
```

> 这段代码将会创建一个新的HTTP Connector，当它接收到HTTP请求时，它会将请求重定向到已配置的HTTPS端口。请确保redirectConnector方法中设置的端口与你的需求相符，setPort方法设置的是你希望HTTP请求监听的端口（默认是8080），而setRedirectPort是你的HTTPS端口（以上代码中为8443）。
> 现在当你尝试通过HTTP访问你的应用时，例如访问 ```http://localhost:8080``` ，Tomcat应当会自动将请求重定向到 ```https://localhost:8443``` 。

### RPC与MQ的区别？以及MQ的使用场景？

1. [RPC介绍链接](https://javaguide.cn/distributed-system/rpc/rpc-intro.html)
1. [消息队列介绍链接](https://javaguide.cn/high-performance/message-queue/message-queue.html)
1. [见链接](https://zhuanlan.zhihu.com/p/97841943)
1. RPC是远程过程调用，MQ是消息队列，**RPC通常是同步**的 请求/响应 调用，**MQ是异步**的流处理
1. N个不同系统相互之间都有RPC调用，依赖程度深，引入MQ降低耦合度
1. MQ实现RPC会造成更大通讯开销，不要强行替代
1. **MQ异步有自动重传**重试，与http同步调用相比能**提高系统的可靠性**(MQ大部分时候用于提高系统的可靠性，很少场景能用来提速)，http要自己实现重传重试的补偿定时任务
1. **异步**只有在接口流程能同步进行时能提高速度，有的业务是链式的，比如下单，下一步操作依赖上一步操作，异步就**没啥用**
1. MQ削峰/限流

### 搜索怎么实现？怎么实现多字段查询？搜索的字段维度？

### Token核心字段？

1. userId
1. 有效期

### user/admin 访问的身份如何控制

使用 Spring 中 AOP 配合自定义注解进行鉴权(目前只实现了方法拦截, 对类拦截要使用反射[后续可能更改为Spring Security]) ;
具体实现在/aop/AuthInterceptor 和 /annotation/AuthCheck 中
