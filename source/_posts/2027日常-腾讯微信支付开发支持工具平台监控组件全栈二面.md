---
title: 2027日常-腾讯微信支付开发支持工具平台监控组件全栈二面
date: 2025-10-15 03:00:00
categories: [面经]
keywords: [面试经历,面经,优化点]
tag: []
description:
---

## 讲一下怎么下单的？

## 每个用户都有接口请求的次数限制，怎么限制？

> 网关统一处理次数限制，每次从Redis里面查剩余次数

## 每次请求都要查Redis的话，调用量大的话性能问题怎么优化？

> 类似库存预扣
> 1.预申请额度，redis里面的额度先划走（日志或redis中记录预申请标记，包含预申请的额度数量、过期时间、申请的机器编号），用完了的话就再从redis中预申请，并将之前的预申请标记设置为已用或直接删掉（改日志或redis中的记录，彻底落库，保证之后不会冲回）
> 2.没用完或预申请的机器宕机的话需要冲回剩余的额度。本地缓存预申请额度设置一个有效期，如果有效期到期后本地仍然有剩余额度，就通过本地机器缓存配置的过期监听器由本地机器自己主动向redis中冲回剩余的额度，并删掉预申请标记。如果本地机器宕机则无法自己主动向redis中冲回剩余的额度，需要部署分布式的定时任务，每隔一段时间检查redis中记录的预申请标记（包含预申请的额度数量、过期时间、申请的机器编号）是否被标记为已用或被删掉，如果没有则认为机器可能宕机，就向redis中冲回剩余的额度，并删掉预申请标记防止重复冲回。（若机器宕机时已经用掉些额度了的话，则最后可能会导致用户实际使用次数超限。但如果是库存预扣，因为订单要刷到MySQL中，机器宕机后可以根据MySQL中的订单数据进行冲回，保证不超限）
> 3.机器主动下线时，也需要向redis中冲回剩余的额度，并删掉预申请标记。

## 有多台机器怎么保证本地的预申请合理？

> 1.可以考虑hash分片保证一定时间内同一用户路由到同一台机器（依然不太好）
> 2.可以考虑每台接到用户请求的机器都预申请额度（没接到用户请求的机器就不申请），向上面那样实现过期冲回剩余额度的功能，保证额度不被一直锁定。

## 在线调试接口是怎么做的？

## 秒杀下单中你这个生成的全局唯一ID是干啥的？内容是啥？怎么生成的？

## 什么时候会去读DB呢？

## 令牌桶限流是怎么弄的？

## 讲一下排行榜的次数是从哪里获取的？

> 端口查询的点击次数

## 具体讲一下实习的时候怎么实现 Modbus 协议获取有效数据的？贪心算法能保证一定是最优解吗，为什么？

> 贪心算法的适用场景，能保证最优的条件：
> 1.贪心选择性质：在某一步做出的本地最优选择，可以被合法地扩展为全局最优解的一部分。换句话说：做出局部最优选择不会妨碍最终得到最优解。
> 2.最优子结构：问题的最优解可以由子问题的最优解组成。即当你做了一个贪心选择后，剩下的子问题和原问题结构类似，且子问题的最优解能组合回全局最优。
> 贪心算法不是最优的场景：
> 1.局部最优不一定能扩展成全局最优：做了一个看起来最好的选择后，后续可能因为这个选择锁死了一些组合空间，使得全局无法最优。
> 2.损失未来选项或资源分配冲突：贪心可能把资源、容量、预算或机会过早耗掉，导致后面的高价值选择无法进行。
> 3.不满足最优子结构：做了贪心选择后，剩下的子问题不再与原问题形式相同，无法继续递归。

## 你的课题是啥？
